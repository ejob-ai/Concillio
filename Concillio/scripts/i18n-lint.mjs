#!/usr/bin/env node
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import JSON5 from 'json5'

const FILE = path.resolve('src/index.tsx')
const SRC = fs.readFileSync(FILE, 'utf8')

function extractDicts(src){
  const tIdx = src.indexOf('function t(')
  if (tIdx === -1) throw new Error('t(lang) not found')
  const qIdx = src.indexOf('?', tIdx)
  if (qIdx === -1) throw new Error('ternary ? not found in t(lang)')
  // find first { after ?
  let i = src.indexOf('{', qIdx)
  if (i === -1) throw new Error('opening { for en not found')
  const enBlock = readBalanced(src, i)
  // find : after en block end
  const afterEn = i + enBlock.length
  const colonIdx = src.indexOf(':', afterEn)
  if (colonIdx === -1) throw new Error('colon : not found after en block')
  // find first { after : for sv
  let j = src.indexOf('{', colonIdx)
  if (j === -1) throw new Error('opening { for sv not found')
  const svBlock = readBalanced(src, j)
  return { enRaw: enBlock, svRaw: svBlock }
}

function readBalanced(s, start){
  let i = start
  let depth = 0
  let str = null // ' or "
  let out = ''
  let escaped = false
  for (; i < s.length; i++){
    const ch = s[i]
    out += ch
    if (str){
      if (escaped){ escaped = false; continue }
      if (ch === '\\'){ escaped = true; continue }
      if ((str === '\'' && ch === '\'') || (str === '"' && ch === '"')){ str = null }
      continue
    }
    if (ch === '\'' || ch === '"'){ str = ch; continue }
    if (ch === '{'){ depth++ }
    else if (ch === '}'){
      depth--
      if (depth === 0){ break }
    }
  }
  return out
}

function parse(raw){
  // raw includes braces, JSON5 can parse object literal syntax
  return JSON5.parse(raw)
}

function typeOf(v){
  if (Array.isArray(v)) return 'array'
  return (v === null) ? 'null' : typeof v
}

function compareShapes(a, b, pathSegs=[], problems=[]){
  const aKeys = new Set(Object.keys(a))
  const bKeys = new Set(Object.keys(b))
  for (const k of aKeys){
    if (!bKeys.has(k)) problems.push({ type:'missing_in_sv', path:[...pathSegs,k].join('.') })
  }
  for (const k of bKeys){
    if (!aKeys.has(k)) problems.push({ type:'extra_in_sv', path:[...pathSegs,k].join('.') })
  }
  for (const k of aKeys){
    if (!bKeys.has(k)) continue
    const va = a[k]
    const vb = b[k]
    const ta = typeOf(va)
    const tb = typeOf(vb)
    if (ta !== tb){
      problems.push({ type:'type_mismatch', path:[...pathSegs,k].join('.'), enType: ta, svType: tb })
      continue
    }
    if (ta === 'object' && va && vb){
      compareShapes(va, vb, [...pathSegs,k], problems)
    } else if (ta === 'array'){
      // attempt shallow element type checks
      const ea = va.find(x=>x!==undefined && x!==null)
      const eb = vb.find(x=>x!==undefined && x!==null)
      if (ea !== undefined && eb !== undefined){
        const tea = typeOf(ea)
        const teb = typeOf(eb)
        if (tea === 'object' && teb === 'object'){
          // compare union of keys across arrays (best effort)
          const keysA = unionKeys(va)
          const keysB = unionKeys(vb)
          const onlyA = keysA.filter(k=>!keysB.includes(k))
          const onlyB = keysB.filter(k=>!keysA.includes(k))
          if (onlyA.length){ problems.push({ type:'array_object_keys_missing_in_sv', path:[...pathSegs,k].join('.'), keys: onlyA }) }
          if (onlyB.length){ problems.push({ type:'array_object_keys_extra_in_sv', path:[...pathSegs,k].join('.'), keys: onlyB }) }
        } else if (tea !== teb){
          problems.push({ type:'array_element_type_mismatch', path:[...pathSegs,k].join('.'), enType: tea, svType: teb })
        }
      }
    }
  }
  return problems
}

function unionKeys(arr){
  const set = new Set()
  for (const it of arr){
    if (it && typeof it === 'object'){
      for (const k of Object.keys(it)) set.add(k)
    }
  }
  return Array.from(set)
}

function genTypes(en){
  const keys = Object.keys(en).sort()
  const union = keys.map(k=>`'${k.replace(/'/g, "\\'")}'`).join(' | ')
  return `// AUTO-GENERATED by scripts/i18n-lint.mjs\nexport type LocalizeKeys = ${union};\n`
}

try{
  const { enRaw, svRaw } = extractDicts(SRC)
  const en = parse(enRaw)
  const sv = parse(svRaw)

  // Dedupe check for EN specific keys (presence, not duplicates here)
  const mustHave = ['tagline_short','head_home_title','head_home_desc','minutes_desc','why_items']
  const missing = mustHave.filter(k => !(k in en))
  if (missing.length){
    console.error('EN dictionary missing keys:', missing)
  }

  const problems = compareShapes(en, sv)
  if (problems.length){
    console.error('i18n-lint: Found problems:')
    for (const p of problems){
      console.error('-', p)
    }
  }

  // generate LocalizeKeys type
  const typesOut = genTypes(en)
  const outPath = path.resolve('src/types/i18n.generated.d.ts')
  fs.mkdirSync(path.dirname(outPath), { recursive: true })
  fs.writeFileSync(outPath, typesOut)

  if (missing.length || problems.length){
    process.exit(1)
  } else {
    console.log('i18n-lint: OK')
  }
} catch (e){
  console.error('i18n-lint error:', e)
  process.exit(1)
}
